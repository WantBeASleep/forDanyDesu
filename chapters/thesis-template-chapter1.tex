\chapter{Аналитическая часть}
\label{chapter1}

\section{Анализ проблемной области и архитектур построения серверных приложений}

Традиционная архитектура на основе клиент-серверной модели является одной из наиболее распространенных архитектур для создания серверных приложений. Эта модель предполагает разделение приложения на две составляющие - клиентскую и серверную. Клиентская составляющая отвечает за интерфейс взаимодействия с пользователем, а серверная - за обработку запросов и предоставление данных.
Основным преимуществом клиент-серверной модели является возможность создания распределенной архитектуры, которая позволяет создавать приложения с большими объемами данных или с большим количеством пользователей. Также этот подход позволяет легко масштабировать и обновлять серверное приложение без влияния на клиентскую составляющую.
Одним из недостатков клиент-серверной модели является ее зависимость от сети. Отказ сети или недоступность сервера может привести к невозможности доступа к приложению. Еще одним недостатком является необходимость настройки и поддержки серверной инфраструктуры, что может требовать отдельных затрат и увеличить стоимость разработки и поддержки серверного приложения.
Для реализации клиент-серверной модели на практике используются различные технологии и инструменты, как проприетарные, так и открытые. Например, для создания серверных приложений могут использоваться языки программирования, такие как Java, Python, Ruby, PHP, а для создания клиентских приложений - HTML, CSS, JavaScript.
Существует также множество фреймворков, библиотек и инструментов, которые предназначены для упрощения разработки серверных приложений на основе клиент-серверной модели. Например, Node.js является популярным фреймворком для создания серверных приложений на JavaScript, а Django и Flask - для Python.
Также используются такие средства, как базы данных, предназначенные для хранения данных приложения, или сервисы и инструменты для автоматизации и управления развертыванием и масштабированием серверных приложений. Кроме того, существуют такие платформы, как Amazon Web Services и Microsoft Azure, которые предоставляют в облаке готовые инструменты для создания и развертывания серверных приложений на основе клиент-серверной модели.

\subsection{Микросервисная архитектура}

Микросервисная архитектура является относительно новым подходом к разработке серверных приложений. Она характеризуется модульностью, то есть каждый модуль является отдельным сервисом, который может быть развернут и масштабирован отдельно от других модулей. Микросервисная архитектура рассматривает приложение как совокупность небольших сервисов, которые представляют отдельные функции приложения. Каждый сервис обычно работает независимо от других сервисов, используя API для обмена данными между другими сервисами.
Основное преимущество микросервисной архитектуры заключается в ее модульности. Это дает возможность быстро отвечать на изменения требований и легко масштабировать приложение по мере необходимости. Другим преимуществом микросервисной архитектуры является возможность использования различных технологий и языков программирования для различных сервисов. Это позволяет использовать наилучшее решение для каждой отдельной задачи. Микросервисная архитектура может быть также более устойчивой и надежной, поскольку имеется возможность аварийного отключения отдельных сервисов, позволяя уменьшить влияние отказа других компонентов на работу приложения в целом.
Существует несколько типов микросервисных архитектур, которые различаются по тому, как организованы и взаимодействуют между собой микросервисы. К одному из распространенных типов микросервисных архитектур относится оркестрованная архитектура [8] – это такая архитектура, в которой существует централизованный компонент или слой, называемый оркестратором, который координирует действия и взаимодействие других микросервисов в системе. Оркестратор отвечает за управление жизненным циклом запросов от клиентов, контроль последовательности выполнения операций и обработку бизнес-логики интеграции между сервисами. Оркестрованная архитектура обеспечивает высокий уровень контроля и координации в распределенных системах, позволяя эффективно управлять сложными процессами и задачами. В то же время, она может создавать единую точку отказа, увеличивая зависимость системы от работы оркестратора.
Ещё одним из распространённых типов микросервисных архитектур является event-driven архитектура – архитектура, в которой микросервисы взаимодействуют через отправку и прием событий. Каждый сервис может публиковать события, на которые другие сервисы могут, соответственно, подписываться и реагировать. К её преимуществам относятся: гибкость (компоненты могут быть легко добавлены или удалены без влияния на другие части системы), масштабируемость (каждый компонент может масштабироваться независимо для обеспечения высокой производительности), отказоустойчивость (отказ одного компонента не блокирует работу всей системы). Однако тут возникает сложность в обеспечении согласованности данных между различными сервисами, управлении событиями и обработке ошибок. 
Также стоит упомянуть про подход API Gateway – данный тип архитектуры использует централизованный шлюз, который является единой точкой входа для всех запросов клиентов к микросервисам или другим системам. Шлюз может выполнять несколько функций, к которым относятся: аутентификация, авторизация, маршрутизация запросов, преобразование протоколов и форматов данных, кеширование, балансировка трафика и другие. Данный подход позволяет сделать архитектуру приложения более гибкой, безопасной и легкой в управлении, а также позволяет централизованно управлять всеми взаимодействиями клиентов с микросервисами, упрощая развертывание и поддержку системы.

Микросервисная архитектура предусматривает разбиение приложения на небольшие независимые сервисы, каждый из которых выполняет строго определённые задачи. Эти сервисы взаимодействуют через сети с использованием API или брокеров сообщений.

\textbf{Преимущества микросервисной архитектуры}:
\begin{itemize}
    \item \textbf{Гибкость масштабирования:} отдельные сервисы масштабируются независимо, что оптимизирует использование ресурсов.
    \item \textbf{Свобода выбора технологий:} команды могут использовать разные языки программирования и инструменты для реализации отдельных сервисов.
    \item \textbf{Лучшая управляемость:} изолированные сервисы упрощают внесение изменений и поддержку.
    \item \textbf{Повышенная устойчивость:} сбой одного сервиса не влияет на работу других.
    \item \textbf{Параллельная разработка:} команды могут работать над разными сервисами одновременно.
\end{itemize}

\textbf{Недостатки микросервисной архитектуры}:
\begin{itemize}
    \item \textbf{Сложность проектирования:} требует тщательного планирования взаимодействия между сервисами.
    \item \textbf{Проблемы с согласованностью данных:} переход к eventual consistency добавляет сложности.
    \item \textbf{Высокие инфраструктурные затраты:} управление множеством сервисов требует дополнительных инструментов, таких как Kubernetes.
    \item \textbf{Увеличение задержек:} сетевое взаимодействие между сервисами медленнее, чем вызовы в памяти.
    \item \textbf{Сложности диагностики:} распределённый характер системы затрудняет выявление и исправление ошибок.
\end{itemize}

\subsection{Монолитная архитектура}

Монолитная архитектура представляет собой подход, при котором всё приложение разрабатывается как единый, неделимый блок. В нём объединены пользовательский интерфейс, бизнес-логика и уровень работы с данными. Такой подход исторически был основным в разработке ПО.

\textbf{Преимущества монолитной архитектуры}:
\begin{itemize}
    \item \textbf{Простота разработки:} начальный этап разработки требует меньше усилий на планирование структуры.
    \item \textbf{Единая кодовая база:} централизованное хранение и управление кодом упрощает процесс разработки и интеграции изменений.
    \item \textbf{Лёгкость развертывания:} однотипные развертывания минимизируют риск несовместимости.
    \item \textbf{Высокая производительность:} отсутствие сетевого взаимодействия между компонентами ускоряет их взаимодействие.
    \item \textbf{Поддержка транзакционности:} встроенные механизмы работы с транзакциями позволяют обеспечить согласованность данных.
\end{itemize}

\textbf{Недостатки монолитной архитектуры}:
\begin{itemize}
    \item \textbf{Сложность масштабирования:} увеличение нагрузки требует масштабирования всего приложения, даже если это касается лишь одного его компонента.
    \item \textbf{Ограничения технологического выбора:} единая технологическая платформа ограничивает возможности внедрения новых инструментов.
    \item \textbf{Рост сложности кода:} по мере увеличения объёма функциональности поддержка системы становится сложнее.
    \item \textbf{Долгое развертывание:} внесение малейших изменений требует пересборки и перезапуска приложения.
    \item \textbf{Уязвимость к сбоям:} сбой в одном компоненте приводит к отказу всей системы.
\end{itemize}


\subsection{Сравнение монолитной и микросервисной архитектур}

Для более наглядного понимания различий между монолитной и микросервисной архитектурами представим их основные аспекты в таблице:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Аспект}                & \textbf{Монолитная архитектура}       & \textbf{Микросервисная архитектура}   \\ \hline
Сложность разработки           & Низкая                                 & Высокая                                \\ \hline
Масштабируемость               & Ограниченная                           & Гибкая                                 \\ \hline
Устойчивость к сбоям           & Низкая                                 & Высокая                                \\ \hline
Технологический выбор          & Ограниченный                           & Гибкий                                 \\ \hline
Развертывание                  & Простое                                & Сложное                                \\ \hline
Поддержка транзакционности     & Простая                                & Сложная                                \\ \hline
Задержки взаимодействия        & Минимальные                            & Увеличенные                            \\ \hline
Затраты на инфраструктуру      & Низкие                                 & Высокие                                \\ \hline
\end{tabular}
\caption{Сравнение монолитной и микросервисной архитектур}
\end{table}

\textbf{Выводы:} Монолитная архитектура лучше подходит для проектов с ограниченным функционалом и небольшими командами, где важны простота и быстрота разработки. Микросервисы же оправданы в сложных, масштабируемых системах с распределёнными командами и высокими требованиями к отказоустойчивости.













\section{Анализ и сравнение паттернов проектирования модулей системы}

Связанность (англ. Coupling) и согласованность (англ. Cohesion) являются фундаментальными концепциями в области разработки программного обеспечения, которые оказывают значительное влияние на читаемость, поддержку, тестируемость и переиспользование кода. В данной работе исследуются эти понятия, их виды, а также взаимосвязь между ними с целью формирования рекомендаций по их применению для повышения эффективности разработки.

\subsection*{Связанность (Coupling)}

Связанность характеризует степень зависимости одного программного модуля от других. Чем выше уровень связанности, тем сильнее изменения в одном модуле отражаются на других. Стремление к низкой связанности (low coupling) является ключевым принципом проектирования, позволяющим минимизировать количество зависимостей между модулями и повысить их автономность.

Существует несколько типов связанности, классифицируемых по степени их зависимости:

\begin{itemize}
    \item \textbf{Content coupling} (содержательная связанность): возникает, когда один модуль полагается на внутреннюю реализацию другого модуля, например, доступ к его локальным данным. Изменения в одном модуле требуют изменений в другом.
    \item \textbf{Common coupling} (общая связанность): модули используют общие данные, например, глобальные переменные. Изменение этих данных затрагивает все модули, которые с ними работают.
    \item \textbf{External coupling} (внешняя связанность): несколько модулей зависят от общего внешнего ресурса, такого как сервис или API. Изменения в этом ресурсе могут привести к некорректной работе модулей.
    \item \textbf{Control coupling} (управляющая связанность): один модуль управляет поведением другого через передачу управляющих сигналов, например, флагов, изменяющих поведение функций.
    \item \textbf{Stamp coupling} (штампованная связанность): модули обмениваются сложными структурами данных, однако используют лишь их часть. Это может приводить к побочным эффектам из-за неполной или изменяемой информации.
    \item \textbf{Data coupling} (связанность по данным): наименее инвазивный тип, при котором модули взаимодействуют исключительно через передачу конкретных данных. Такой подход минимизирует взаимозависимость.
\end{itemize}

\subsection*{Согласованность (Cohesion)}

Согласованность характеризует степень внутренней связанности функциональных элементов модуля. Высокая согласованность подразумевает, что все компоненты модуля ориентированы на выполнение одной конкретной задачи или функции, что улучшает читаемость и управляемость кода.

Типы согласованности включают:

\begin{itemize}
    \item \textbf{Functional cohesion} (функциональная согласованность): модуль объединяет весь необходимый функционал для выполнения одной задачи.
    \item \textbf{Sequential cohesion} (последовательная согласованность): результаты одной функции используются в качестве входных данных для другой.
    \item \textbf{Communication cohesion} (коммуникационная согласованность): все элементы модуля работают с одними и теми же данными.
    \item \textbf{Procedural cohesion} (процедурная согласованность): элементы модуля выполняются в определенной последовательности, необходимой для достижения результата.
    \item \textbf{Temporal cohesion} (временная согласованность): функции модуля сгруппированы на основе их выполнения в определенный момент времени (например, при обработке ошибок).
    \item \textbf{Logical cohesion} (логическая согласованность): элементы модуля объединены логически общей функцией, но могут отличаться по своей природе (например, обработка различных типов ввода).
    \item \textbf{Coincidental cohesion} (случайная согласованность): элементы модуля не связаны логически, что делает модуль хаотичным и сложным для понимания.
\end{itemize}

\subsection*{Взаимосвязь между Coupling и Cohesion}

Связанность и согласованность находятся в сложной взаимозависимости. Уменьшение связанности обычно способствует увеличению согласованности и наоборот. Например, избыточная согласованность может привести к росту зависимости между модулями, что увеличивает связанность. Таким образом, ключевым аспектом является нахождение оптимального баланса, который обеспечит поддержку высокого уровня согласованности при минимально возможной связанности.

\subsection*{Примеры применения}

Рассмотрим два варианта компоновки модулей:

\begin{itemize}
    \item Низкая согласованность:
    \begin{verbatim}
    ./internal
       ./model
          product.go
          user.go
       ./factory
          product_factory.go
          user_factory.go
       ./repository
          product_repository.go
          user_repository.go
    \end{verbatim}
    В данном случае функционал рассредоточен, что усложняет понимание структуры приложения и взаимодействия его компонентов.
    
    \item Высокая согласованность:
    \begin{verbatim}
    ./internal
       ./product
          product.go
          product_factory.go
          product_repository.go
       ./user
          user.go
          user_factory.go
          user_repository.go
    \end{verbatim}
    Здесь модули структурированы по функциональным областям, что повышает согласованность и упрощает работу с кодом.
\end{itemize}


Применение принципов низкой связанности и высокой согласованности позволяет создавать поддерживаемые, масштабируемые и понятные программные системы. Их использование способствует не только повышению качества кода, но и ускорению разработки, что особенно важно в современных условиях высокой конкуренции и быстрого изменения требований.





\subsection{Луковая архитектура}
\textbf{Луковая архитектура} была предложена Джеффри Палермо в 2008 году как расширение гексагональной архитектуры. Её цель — облегчить поддержку приложений за счёт разделения аспектов и строгих правил взаимодействия слоёв.

\subsubsection{Основная идея}
Луковая архитектура предполагает многослойную организацию системы, где каждый слой зависит только от внутреннего слоя. Центральным слоем всегда является независимый слой, который представляет собой сердцевину архитектуры. Остальные слои располагаются вокруг него, создавая структуру, похожую на лук.

\textbf{Ключевые принципы:}
\begin{itemize}
    \item Приложение строится вокруг независимой объектной модели.
    \item Внутренние слои определяют интерфейсы, внешние — реализуют их.
    \item Зависимости направлены к центру.
    \item Код предметной области изолирован от инфраструктуры.
\end{itemize}

\subsubsection{Слои}
\textbf{Domain Model:} содержит основные сущности и поведение предметной области, например, валидацию данных.

\textbf{Domain Services:} реализует бизнес-логику, которая не связана с конкретными сущностями, например, расчёт стоимости заказа.

\textbf{Application Services:} оркестрирует бизнес-логику, например, обработку запроса на создание заказа.

\textbf{Infrastructure:} реализует интерфейсы и адаптеры для работы с базами данных, внешними API и другими ресурсами.

\subsubsection{Преимущества}
\begin{itemize}
    \item Независимость предметной области от инфраструктуры.
    \item Гибкость замены внешних слоёв.
    \item Высокая тестируемость.
\end{itemize}

\subsubsection{Недостатки}
\begin{itemize}
    \item Сложность обучения.
    \item Необходимость создания множества интерфейсов.
\end{itemize}

\subsection{Hexagonal Architecture}
\textbf{Hexagonal Architecture} (также известная как Ports and Adapters) была предложена Alistair Cockburn. Её цель — устранить зависимость бизнес-логики от внешних систем и сделать приложение более гибким и тестируемым.

\subsubsection{Основная идея}
Hexagonal Architecture представляет приложение в виде шестиугольника, где каждая сторона представляет интерфейс (порт) для взаимодействия с внешними системами (адаптерами). Центр архитектуры — это бизнес-логика, изолированная от деталей реализации.

\textbf{Ключевые принципы:}
\begin{itemize}
    \item Бизнес-логика полностью изолирована от инфраструктуры.
    \item Взаимодействие с внешним миром происходит через порты и адаптеры.
    \item Внешние системы подключаются через адаптеры, соответствующие определённым портам.
\end{itemize}

\subsubsection{Слои}
\textbf{Core (Business Logic):} центральная часть архитектуры, содержащая доменные сущности и бизнес-правила.

\textbf{Ports:} интерфейсы, через которые осуществляется взаимодействие между Core и внешними системами.

\textbf{Adapters:} реализация портов для подключения конкретных технологий, таких как базы данных, веб-сервисы и т.д.

\subsubsection{Преимущества}
\begin{itemize}
    \item Гибкость: легко заменять внешние системы, не затрагивая бизнес-логику.
    \item Тестируемость: изолированная бизнес-логика упрощает написание модульных тестов.
    \item Чёткое разделение обязанностей.
\end{itemize}

\subsubsection{Недостатки}
\begin{itemize}
    \item Сложность проектирования и реализации.
    \item Дополнительные накладные расходы на создание портов и адаптеров.
\end{itemize}

\subsection{Чистая архитектура}
\textbf{Чистая архитектура}, предложенная Робертом Мартином, основывается на идеях Onion и Hexagonal архитектур. Её ключевая цель — изолировать бизнес-логику от деталей реализации.

\subsubsection{Базовые принципы}
\begin{itemize}
    \item Использование принципов SOLID.
    \item Разделение системы на слои.
    \item Независимость бизнес-логики от инфраструктуры.
    \item Тестируемость бизнес-логики без внешних зависимостей.
\end{itemize}

\subsubsection{Слои}
\textbf{Domain:} содержит общие бизнес-правила, структуры и интерфейсы.

\textbf{Application:} реализует конкретные сценарии использования, например, обработку запросов.

\textbf{Presentation:} отвечает за взаимодействие с пользователем через REST API, CLI и т.д.

\textbf{Infrastructure:} содержит детали реализации, такие как доступ к базе данных или внешние сервисы.

\subsubsection{Пересечение границ}
В чистой архитектуре зависимости направлены внутрь. Внешние слои реализуют интерфейсы, определённые внутренними слоями. Это достигается за счёт принципа инверсии зависимостей (DIP).

\subsubsection{Преимущества}
\begin{itemize}
    \item Независимость от фреймворков и инфраструктуры.
    \item Простота тестирования.
    \item Переносимость и возможность разделения на микросервисы.
\end{itemize}

\subsubsection{Недостатки}
\begin{itemize}
    \item Требуется строгое разделение бизнес-правил.
    \item Возможность излишнего усложнения структуры.
\end{itemize}


\textbf{Вывод}


\textbf{Чистая архитектура} представляет собой эволюцию луковой и гексагональной архитектур, сохраняя их принципы, но делая больший акцент на SOLID и изоляции бизнес-логики. Она подходит для сложных систем, требующих высокой гибкости и тестируемости, но может быть избыточной для небольших приложений.








\section{Анализ инструментов применяемых для реализации системы}

\subsection{Взаимодействие микросервисов} 

Взаимодействие между микросервисами имеет критическое значение для обеспечения их эффективной работы и
достижения бизнес-целей. Существует два основных подхода к взаимодействию: синхронное и асинхронное,
каждый из которых служит своим целям и задачам.

Синхронное взаимодействие необходимо в ситуациях, когда требуется немедленная обратная связь.
Например, когда клиент получает данные из базы данных или выполняет операции, которые требуют
актуальной информации в реальном времени. В таких сценариях задержка в получении ответа может нарушить
логическую последовательность действий, и важно обеспечить, чтобы данные были актуальны на момент выполнения
запроса.

Асинхронное взаимодействие, в свою очередь, используется в случаях, когда немедленный ответ не требуется.
Это позволяет микросервисам отправлять запросы и продолжать выполнять свои задачи, не дожидаясь ответа.
Например, в случаях обработки фоновых задач или выполнения операций, которые могут быть выполнены позже,
асинхронные подходы позволяют разгружать сервисы и поддерживать их работу без блокировок. Это особенно выгодно
в сценариях с высокой нагрузкой, когда множество запросов могут приходить одновременно.

\subsubsection{Синхронное взаимодействие}

Микросервисы могут синхронно общаться между собой с использованием различных технологий и протоколов. 
В этом контексте рассмотрим четыре популярных метода взаимодействия: HTTP/REST API, gRPC, GraphQL и WebSocket.

В большинстве случаев для микросервисов, которые обмениваются фиксированными данными, использование GraphQL 
может быть излишним, поскольку этот подход предназначен для динамического запроса данных. В сценариях, 
где структуры данных заранее известны и не требуют изменения, REST API будет более простым и 
понятным решением. То же касается и WebSocket: двунаправленный стриминг данных может быть избыточным для 
многих бизнес-приложений, где достаточно стандартного запроса и ответа.

Таким образом, основные методы, которые стоит рассмотреть для синхронного взаимодействия микросервисов, — 
это HTTP/REST API и gRPC.


\textbf{HTTP/REST API}
HTTP/REST API — это один из самых распространенных способов синхронного взаимодействия между микросервисами. Каждый микросервис предоставляет набор эндпоинтов, к которым другие сервисы могут обращаться для выполнения операций и получения данных. Используя стандартные методы HTTP (GET, POST, PUT, DELETE), микросервисы обмениваются сообщениями с четко определенными правилами и структурой.


\textbf{Преимущества использования HTTP/REST}
\begin{itemize}
    \item \textbf{Простота}: REST API легко реализовать и документировать. Он основан на понятных стандартах HTTP и может использоваться практически на любой платформе.
    \item \textbf{Читаемость}: Структура URL и использование HTTP-методов делают интерфейс API интуитивно понятным и удобным для работы разработчиков.
    \item \textbf{Совместимость}: REST API может легко взаимодействовать с разными языками программирования и платформами, что делает его универсальным решением для микросервисной архитектуры.
\end{itemize}


\textbf{gRPC}
gRPC, разработанный Google, представляет собой высокопроизводительный фреймворк для удаленных вызовов процедур (RPC), который поддерживает множество языков программирования. Он использует HTTP/2 для передачи данных, что обеспечивает преимущества, такие как многопоточность и меньшие задержки при передаче информации.


\textbf{Преимущества использования gRPC}
\begin{itemize}
    \item \textbf{Производительность}: Использование HTTP/2 позволяет gRPC эффективно обрабатывать множество параллельных запросов, что делает его более производительным, чем традиционные REST API.
    \item \textbf{Статическая типизация}: gRPC использует Protocol Buffers для описания структуры данных, что позволяет разработчикам строго определять, какой тип данных будет передаваться. Это обеспечивает дополнительную безопасность и позволяет избежать ошибок при взаимодействии между сервисами.
    \item \textbf{Автогенерация кода}: Удобство разработки достигается благодаря автоматической генерации клиентского кода на разных языках, что ускоряет процесс создания микросервисов.
\end{itemize}


\textbf{Сравнение HTTP/REST API и gRPC}
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Характеристика}           & \textbf{HTTP/REST API}                          & \textbf{gRPC}                                     \\ \hline
        Протокол                  & Основан на HTTP/1.1 или HTTP/2            & Использует HTTP/2                             \\ \hline
        Структура данных          & Ограничена JSON/XML                        & Использует Protocol Buffers для сериализации \\ \hline
        Типизация                 & Нестатическая типизация (JSON)            & Статическая типизация (протоколы определены) \\ \hline
        Производительность         & Может иметь более высокую задержку         & Обычно низкая задержка, высокая производительность \\ \hline
        Поддержка потоковой передачи & Ограниченная                                & Поддерживает стриминг (односторонний и двунаправленный) \\ \hline
        Автогенерация клиента     & Обычно требует ручного создания клиентского кода & Генерация клиентского кода на многих языках из .proto-файлов \\ \hline
        Простота и читаемость     & Прост в реализации, легко понимается      & Требует понимания Protocol Buffers и gRPC, может быть сложнее для освоения \\ \hline
        Универсальность           & Широко используется и поддерживается, совместим с многими технологиями & Хорошо подходит для систем с высокой нагрузкой, но менее распространен \\ \hline
        Тестирование и отладка   & Легче тестировать с инструментами для работы с HTTP (например, Postman) & Может потребоваться больше усилий для настройки инструментов тестирования \\ \hline
    \end{tabular}
    \caption{Сравнение HTTP/REST API и gRPC}
\end{table}


\textbf{Заключение}
Нашей системе не требуется возможность динамической типизации, поэтому выбор сделать в сторону gRPC.

\subsubsection{Асинхронное взаимодействие} % kafka



Асинхронное взаимодействие между микросервисами позволяет увеличить производительность и гибкость распределенных систем. В этом подходе микросервисы могут обмениваться данными без необходимости дожидаться ответа, что снижает задержки и повышает общую эффективность системы. Рассмотрим основные методы асинхронного взаимодействия.


\textbf{Основные методы асинхронного взаимодействия}
\begin{itemize}
    \item \textbf{Очереди сообщений}: Использование систем обмена сообщениями, таких как RabbitMQ, Apache Kafka или Redpanda, позволяет отправлять сообщения между микросервисами без прямого связывания. Один сервис может отправлять сообщения в очередь, а другой — извлекать их и обрабатывать по мере возможности. Это гарантирует, что сервисы могут работать независимо друг от друга и не блокируют друг друга в случае высокой нагрузки.
    \item \textbf{Событийно-ориентированная архитектура}: В этой архитектуре микросервисы реагируют на события, происходящие в системе. События могут генерироваться различными компонентами и служить сигналами для других микросервисов о том, что произошло что-то важное (например, изменение состояния, завершение задачи и т. д.). Это позволяет строить более гибкие и масштабируемые системы.
    \item \textbf{HTTP-события (Webhooks)}: Использование вебхуков позволяет микросервису отправлять HTTP-запросы в другие сервисы при наступлении определённых событий. Это простой способ интеграции, позволяющий уведомлять другие службы о произошедших изменениях или событиях.
\end{itemize}

Выбор в сторону очередей сообщений также обуславливается необходимостью наличия механизма Dead Letter Queue (DLQ), который позволяет обрабатывать ошибки при отправке и получении сообщений. Кроме того, мы стремимся автоматизировать хранение сообщений, что делает использование очередей сообщений предпочтительным решением.


\textbf{Описание систем очередей сообщений}
\begin{itemize}
    \item \textbf{Apache Kafka}:
            - Kafka — это распределенная платформа для потоковой передачи данных, которая обеспечивает высокую пропускную способность и низкую задержку. Она работает по принципу публикации и подписки, позволяя множеству клиентов читать и писать сообщения.
            - \textbf{Назначение}: Идеально подходит для обработки потоков данных в реальном времени и хранения больших объемов событий с возможностью их долговременного хранения.
    \item \textbf{Redpanda}:
            - Redpanda — это высокопроизводительная, совместимая с Kafka, распределенная система сообщений, оптимизированная для работы с потоками данных в реальном времени.
            - \textbf{Назначение}: Обеспечивает низкую задержку и простоту настройки, что делает её предпочтительной для решений, требующих высокой производительности. 

    \item \textbf{Apache Pulsar}:
            - Pulsar — это распределенная система потоковой передачи данных, которая поддерживает многопоточность и управление потоками. Она предоставляет гибкий подход к очередям сообщений и событиям.
            - \textbf{Назначение}: Отличается поддержкой долгосрочного хранения сообщений и сложных сценариев работы с геораспределёнными данными.
\end{itemize}



\textbf{Сравнение систем очередей сообщений}
Ниже представлено сравнение преимуществ и недостатков Apache Kafka, Redpanda и Apache Pulsar.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Система}            & \textbf{Преимущества}                          & \textbf{Недостатки}                                \\ \hline
        \textbf{Apache Kafka}       & - Высокая надежность                    & - Сложность настройки и администрирования     \\ \hline
                                   & - Масштабируемость                       & - Требует дополнительных ресурсов              \\ \hline
                                   & - Долговременное хранение данных         & - Зависимость от Zookeeper                      \\ \hline
        \textbf{Redpanda}           & - Низкая задержка                        & - Меньшая экосистема поддержки                 \\ \hline
                                   & - Простота настройки                     &                                                \\ \hline
                                   & - Совместимость с Kafka                 &                                                \\ \hline
        \textbf{Apache Pulsar}      & - Гибкость                               & - Сложность архитектуры и настройки            \\ \hline
                                   & - Поддержка геораспределённых данных    & - Меньшая популярность по сравнению с Kafka    \\ \hline
                                   & - Высокая масштабируемость              &                                                \\ \hline
    \end{tabular}
    \caption{Сравнение систем очередей сообщений}
\end{table}


\textbf{Заключение}
Асинхронное взаимодействие, организованное через очереди сообщений, является эффективным способом повышения производительности и устойчивости микросервисов. Учитывая возможности по снижению задержки и простой настройке, мы выбрали Redpanda как предпочтительное решение для организации асинхронного взаимодействия между микросервисами.


\subsection{Хранение данных} % psql + s3


\textbf{Реляционные базы данных (RDBMS)}: Реляционные базы данных, такие как MySQL и PostgreSQL, предлагают структурированный способ хранения данных с использованием таблиц, что позволяет легко реализовать связи между ними. Они подходят для большинства приложений, требующих согласованности и целостности данных.


\textbf{Описание реляционных баз данных}

1. \textbf{MySQL}:
   - \textbf{Описание}: MySQL — это популярная реляционная база данных с открытым исходным кодом, которая используется во множестве веб-приложений и сервисов. Она известна своей производительностью, простотой настройки и широким сообществом.
   - \textbf{Назначение}: Широко используется для веб-приложений, особенно тех, которые требуют быстрого доступа к данным.

2. \textbf{PostgreSQL}:
   - \textbf{Описание}: PostgreSQL — это мощная объектно-реляционная база данных с открытым исходным кодом, которая поддерживает различные типы данных и расширенные функции, такие как работа с JSON и поиск по полнотекстовому содержимому.
   - \textbf{Назначение}: Подходит для сложных и крупных приложений, требующих расширенной функциональности обработки данных.


\textbf{Сравнение MySQL и PostgreSQL}
Ниже представлено сравнение преимуществ и недостатков MySQL и PostgreSQL.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Система}            & \textbf{Преимущества}                          & \textbf{Недостатки}                                \\ \hline
        \textbf{MySQL}              & - Высокая производительность                   & - Ограниченная поддержка сложных запросов       \\ \hline
                                   & - Простота настройки                           & - Менее гибкая работа с типами данных            \\ \hline
                                   & - Широкое сообщество и поддержка              & - Нет полной поддержки ACID в некоторых режимах  \\ \hline
        \textbf{PostgreSQL}        & - Поддержка сложных запросов и индексов       & - Меньшая производительность для простых операций   \\ \hline
                                   & - Расширенные функции для работы с данными    & - Сложнее в настройке и администрировании        \\ \hline
                                   & - Полная поддержка ACID и транзакций          &                                                  \\ \hline
    \end{tabular}
    \caption{Сравнение MySQL и PostgreSQL}
\end{table}


\textbf{Заключение}

Учитывая наши требования и специфику приложений, мы выбираем PostgreSQL как основное решение для хранения данных в нашей архитектуре.

\subsection{Авторизация}


В современном веб-разработке авторизация пользователей является важной частью обеспечения безопасности и управления доступом к ресурсам. Существует несколько подходов к авторизации, каждый из которых имеет свои особенности, преимущества и недостатки. Два самых популярных метода авторизации — это использование сессий и JSON Web Tokens (JWT). В этом обзоре мы рассмотрим основные аспекты каждого из этих подходов.


\textbf{Подход 1: Авторизация с использованием сессий}
Авторизация с использованием сессий предполагает классический подход к управлению состоянием пользователя. 
Когда пользователь выполняет вход в систему, сервер создает сессию и сохраняет информацию о пользователе, 
а также уникальный идентификатор сессии (обычно в виде куки) в браузере.



\textbf{Преимущества}
\begin{itemize}
    \item \textbf{Безопасность}: Сессии могут быть безопаснее, так как данные о пользователе хранятся на сервере, и доступ к ним ограничен.
    \item \textbf{Управление сессиями}: Сервер может контролировать время жизни сессии и управлять активными сессиями (например, отключать их по запросу пользователя).
    \item \textbf{Простота реализации}: Для простых приложений реализация сессий может быть проще и привычнее для разработчиков.
\end{itemize}

\textbf{Недостатки}
\begin{itemize}
    \item \textbf{Сложности с масштабированием}: В распределенных системах требуется дополнительная архитектура для хранения сессий (например, база данных или кэш), что может усложнить разработку.
    \item \textbf{Зависимость от состояния}: Поскольку сессии хранят состояние на сервере, это может ограничить возможность использования микросервисной архитектуры.
\end{itemize}


\textbf{Подход 2: Авторизация с использованием JWT}

JSON Web Tokens (JWT) — это подход к авторизации, основанный на использовании токенов. Когда пользователь входит в систему, сервер генерирует токен, который содержит зашифрованную информацию о пользователе и отправляет его клиенту. Клиент хранит этот токен и включает его в заголовки запросов при доступе к защищённым ресурсам.

\textbf{Преимущества}
\begin{itemize}
    \item \textbf{Безсостояние}: JWT не требуют хранения состояния на сервере. Токен самостоятельно хранит информацию о пользователе, что упрощает масштабирование и работы в распределенных системах.
    \item \textbf{Безопасность}: Токены можно подписывать и шифровать, что добавляет уровень защиты данных.
    \item \textbf{Гибкость}: JWT можно использовать для разных типов приложений, включая веб-приложения, мобильные приложения и API.
\end{itemize}

\textbf{Недостатки}
\begin{itemize}
    \item \textbf{Управление сроком действия}: JWT имеют фиксированный срок действия, и их нужно будет обновлять. Отзыв токена может быть сложнее реализовать.
    \item \textbf{Размер}: Токены могут быть крупнее, чем идентификаторы сессий, что может отрицательно сказаться на производительности при частом использовании в заголовках запросов.
\end{itemize}


\textbf{Заключение}

JWT более удобный и простой в реализации из-за того что не требуется хранение состояния на сервере.



% Это обзорно-аналитическая глава, в которой требуется отразить:

% \begin{itemize}
% 	\item результат изучения различных существующих методов решения задач в рамках проблематики УИРа/диплома (иногда даже в смежных областях), это обзорный аспект, который пишется, в основном, на основе имеющейся литературы или/и программного обеспечения;
% 	\item сравнение (с какой-либо определенной целью) этих методов и средств.
% \end{itemize}

% Приведенные ниже названия пунктов являются очень примерными, их состав и структура сильно зависят от специфики конкретной работы.




% %Большие отсупы --- это хорошо. Облегчает чтение длинных <<простыней>> текста
% \section{Общий анализ проблематики \dots}

% \begin{annotation}
% В случае РСПЗ, так оформляется аннотация к разделу. Такая же аннотация, только более общая, должна быть для главы. После аннотации может следовать рабочая или финальная версия текста соответствующего раздела. В случае ПЗ, таких аннотаций быть не должно.
% \end{annotation}

% \dots

% Результаты анализа полезно оформлять в виде таблиц (см. табл. \ref{tbl:cmp-1}).

% \begin{table}%
% \caption{Результаты сравнения нескольких программных систем}\label{tbl:cmp-1}
% \centering
% \begin{tabular}{|l|l|c|c|c|c|}

% \hline

% \textnumero & Название системы & Показатель 1 & Показатель 2 & Показатель 3 & Показатель 4 \\

% \hline

% \end{tabular}
% \end{table}


% \section{Анализ особенностей \dots}

% Сначала приведем пример более сложной таблицы (см. табл. \ref{tbl:cmp-adv} и 
% \ref{tbl:cmp-2}).

% \begin{table}%
% \caption{Таблица с длинным, многострочным названием, чтобы показать, как форматируется такой заголовок}
% \label{tbl:cmp-adv}
% \centering
% \begin{tabular}{|l|l|c|c|c|c|}

% \hline

% \textnumero & Название системы & Показатель 1 & Показатель 2 & Показатель 3 & Показатель 4 \\

% \hline

% \end{tabular}
% \label{tbl:cmp-2}
% \end{table}


% А теперь, продемонстрируем, как должна выглядеть иллюстрация (см. рис. \ref{pic:lambda-cube}).

% \begin{figure}[t]%
% \begin{center}
% \includegraphics[width=.5\columnwidth]{./img/lambda-cube.png}%
% \end{center}
% \caption{Ламбда-куб Барендрегта}%
% \label{pic:lambda-cube}%
% \end{figure}

% А теперь, продемонстрируем, как должна выглядеть иллюстрация с длинной подрисуночной подписью (см. рис. \ref{pic:lambda-cube-long-caption}).

% \begin{figure}[t]%
% 	\begin{center}
% 		\includegraphics[width=.5\columnwidth]{./img/lambda-cube.png}%
% 	\end{center}
% 	\caption{Ламбда-куб Барендрегта, иллюстрирующий многообразие систем типизации с точки зрения четырех базовых видов зависимостей между типами и объектами: термов от термов, термов от типов, типов от типов и типов от термов.}%
% 	\label{pic:lambda-cube-long-caption}%
% \end{figure}

% \subsection{Ссылки на литературу}

% В этой версии шаблона используется BibLaTeX, основанный на biber и BibTeX.
% Поэтому для оформления списка литературы используются два файла:
% \texttt{thesis-bibl.tex} и \texttt{biblio.bib}. Использование BibTex дает ряд
% преимуществ. Не нужно заботиться о порядке сортировки, это делается
% автоматически; не нужно заботиться, на какие элементы библиографии есть ссылки
% --- печатаются только использованные в тексте элементы. Кроме того, многие
% курсовые проекты выполняются на протяжении ряда лет. С BibTex проще собирать
% список литературы и управлять им.

% Ссылки на литературу даются посредством команды \texttt{\textbackslash{}cite},
% например~\cite{Lermontov}, или~\cite{Pokrovski}. Ссылка является частью
% предложения, поэтому должна идти до точки. Поддерживаются ссылки на несколько
% источников сразу, к примеру~\cite{Borozda,Lagkueva,Methodology,Lermontov}.

% На все элементы списка литературы должны быть ссылки из текста. При
% использовании команды \texttt{\textbackslash{}cite} это происходит
% автоматически. Отсутствиессылок на литературу из текста допускается в РСПЗ,
% т.~е. в РСПЗ список литературы скорее имеет смысл списка подобранной литературы
% по теме или библиографии. Для того, чтобы в списке литературы отобразились
% источники, на которые отсутствуют ссылки в тексте, следует использовать команду
% \texttt{\textbackslash{}nocite}. К примеру, \texttt{\textbackslash{}nocite\{*\}}
% выводит в список литературы все содержимое подключенных BibTeX файлов, вставляя
% невидимые ссылки на них.

% \section{Сравнительный анализ алгоритмов \dots}

% \dots





% \section{Сравнительный анализ программных средств \dots}

% \dots




\section{Выводы}

\begin{enumerate}
	\item Выполнен анализ архитектурных стилей построения систем, с учетом требований к динамической расширяемости отдельных модулей системы, выбрана микросервисная архитектура с применением API Gateway.
	\item Проанализированы основные архитектурные паттерны построения приложений. Clean Architecture за счет преобраладания SOLID, разбиения на слои и преимуществ Dependency inversion выбрана как основа написания микросервисов.
	\item Проанализированных основные инструменты для разработки системы, произведены сравнения аналогов\\
        - для синхронного взаимодействия между микросервисами выбран gRPC, за счет строгой типизации контрактов и производительности за счет сериализации данных.\\
        - для асинхронного взаимодействия между микросервисами выбран подход с брокером сообщений, за счет универсальности и отказоустойчивости. В качестве реализации выбрана RedPanda, Kafka совместимое API с наибольшей производительностью.\\
        - для хранения структурированных данных выбрана PostgreSql, за счет развитой надежности и удобства\\
        - для хранения неструтурированных данных выбрано NoSQL хранилище S3 Minio.\\
        - в качестве схемы авторизации выбрана схема с JWT токенами, которая позволяет не хранить активное состоянии на серверной стороне.\\
\end{enumerate}



\section{Постановка задачи научно иследовательской работы}
\begin{enumerate}
	\item Проектирование и разработка системы серверного приложения системы «Интеллектуальный ассистент врача УЗИ» на основе выбранных инструментов и подходов.
	\item Тестирование и оценка разработанной системы и ее производительности. Устранение недостатков при наличии.
\end{enumerate}


%%% Local Variables:
%%% TeX-engine: xetex
%%% eval: (setq-local TeX-master (concat "../" (seq-find (-cut string-match ".*-3-pz\.tex$" <>) (directory-files ".."))))
%%% End:
