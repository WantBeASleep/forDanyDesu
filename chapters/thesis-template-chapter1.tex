\chapter{Анализ подходов к разработке серверных приложений ИИ ассистентов}
\label{chapter1}

\section{Анализ применения ИИ ассистентов в медицине}

\subsection{Анализ основных областей применения ИИ ассистентов}
Государственное направление по улучшению всех жизненных сфер путем оцифровки, приводит к многочисленным инновациям и крупномасштабным ИТ-проектам. Реализация информационных технологий происходит в области здравоохранения это ключевой показатель уровня жизни страны.\\
Первоначально цифровизация медицины была предназначена для повышения диагностической эффективности и сокращения времени, необходимого для предоставления медицинских услуг. Рутина и сложные задачи передаются на производительность устройства и выполняются с использованием различных технических достижений. С этой целью были созданы многие системы и платформы, которые сокращают время для реализации стандартных диагностических процессов. В этом списке системы с искусственным интеллектом (ИИ) могут быть важны для замены ручной работы интеллектуальными навыками из различных отраслей. Искусственный интеллект - это область науки и техники, которая позволяет компьютерам и программам выполнять интеллектуальные задачи. У него есть возможность выполнять различные задачи, учиться при их использовании и адаптироваться к новым задачам и контекстам. Кроме того, ИИ может выступать в качестве дополнительной аналитической перспективы, позволяя упростить многие процессы с помощью анализа данных и вопросов поиска схемы.\\
Искусственный интеллект может изменить систему здравоохранения, автоматизируя многие из ее аспектов, позволяя сотрудникам сосредоточиться на основных задачах, связанных с уходом и лечением пациентов. Системы здравоохранения на основе искусственного интеллекта являются отличительной скоростью, дополненными простым использованием и снижением затрат, что делает их неотъемлемой частью разработки.\\
Сфера здоровья, в которой активно используется искусственный интеллект, может быть разделена на четыре основных частей.

\begin{itemize}
    \item используется графическая информация (анализ результатов радиационной диагностики).
    \item принятие и диагноз на основе различных метаданных.
    \item Дистанционные консультации и обеспечение контроля здоровья пациентов.
    \item Исследование лекарств, создание и реализация.
\end{itemize}

\subsection{Обзор существующих систем поддержки принятия врачебных решений с применением искусственного интеллекта}
В России значительное число медицинских компаний и стартапов также используют искусственный интеллект для поддержки медицинских решений. Основными областями работы являются анализ исследований на флуоресцентных (FLG), X-Ray -изображениях (RG) и компьютерной томографии (КТ).\\
Крупнейшие ИИ медицинские системы:\\
\begin{itemize}
    \item MDDC создается для поддержки медицинских решений в соответствии с первоначальным диагнозом, инструментами и лабораториями. Система интегрирована в различные системы данных и источники данных и использование технологий искусственного интеллекта для обработки и анализа данных о здоровье.
    \item Celsus - это система поддержки медицинских решений, основанных на технологиях искусственного интеллекта, позволяя вам анализировать цифровые медицинские изображения, обнаруживать объекты и автоматически формировать результаты. Основными областями разработки являются анализ изображений X-RAY и флуорографии, анализ КТ и легких.
    \item «ФтизисБиоМед», продукты и услуги широко используются в практической медицине, чтобы снизить неправильный диагноз и обеспечить раннюю диагностику на ранних стадиях заболевания. Среди наиболее важных событий в компании можно выделить услуги для анализа медицинских изображений (флурограмма и X-Rays) на основе ИИ.
\end{itemize}
Основываясь на анализе лидеров в области исследований искусственного интеллекта в области медицины, мы можем сделать вывод, что ультразвуковой анализ щитовидной железы является одной из наиболее актуальной задач. Выбор области исследований и скачок в финансировании проектов медицинских технологий произошел в 2020 году, объясняющий эпидемиологическую ситуацию с Covid-19. Самым важным решением, принятым в то время, был постановление правительства о оцифровке системы здравоохранения и создании различных государственных платформ здравоохранения поэтому решение создать полную систему для диагностики гормональных заболеваний в соответствии с изображением узи снимков является наиболее перспективным способом достижения цели на работе.\\
Кроме того, основные направления задач выполняются с помощью систем, которые можно различить это обнаружение патологии на основании графических результатов клинических исследований и предварительной диагностики. Этот выбор обусловлен сложностью диагностического процесса и необходимостью высокой подготовки для экспертов.\\


\section{Анализ основных архитектур для построения серверных приложений}

Традиционная архитектура на основе клиент-серверной модели является одной из наиболее распространенных архитектур для создания серверных приложений. Эта модель предполагает разделение приложения на две составляющие - клиентскую и серверную. Клиентская составляющая отвечает за интерфейс взаимодействия с пользователем, а серверная - за обработку запросов и предоставление данных.
Основным преимуществом клиент-серверной модели является возможность создания распределенной архитектуры, которая позволяет создавать приложения с большими объемами данных или с большим количеством пользователей. Также этот подход позволяет легко масштабировать и обновлять серверное приложение без влияния на клиентскую составляющую.
Одним из недостатков клиент-серверной модели является ее зависимость от сети. Отказ сети или недоступность сервера может привести к невозможности доступа к приложению. Еще одним недостатком является необходимость настройки и поддержки серверной инфраструктуры, что может требовать отдельных затрат и увеличить стоимость разработки и поддержки серверного приложения.
Для реализации клиент-серверной модели на практике используются различные технологии и инструменты, как проприетарные, так и открытые. Например, для создания серверных приложений могут использоваться языки программирования, такие как Golang, Java, Python, Ruby, PHP, а для создания клиентских приложений - HTML, CSS, JavaScript.
Существует также множество фреймворков, библиотек и инструментов, которые предназначены для упрощения разработки серверных приложений на основе клиент-серверной модели. Например, Node.js является популярным фреймворком для создания серверных приложений на JavaScript, а Django и Flask - для Python.
Также используются такие средства, как базы данных, предназначенные для хранения данных приложения, или сервисы и инструменты для автоматизации и управления развертыванием и масштабированием серверных приложений. Кроме того, существуют такие платформы, как Яндекс Облако и Selectel, которые предоставляют в облаке готовые инструменты для создания и развертывания серверных приложений на основе клиент-серверной модели.

\subsection{Микросервисная архитектура}

Микросервисная архитектура является относительно новым подходом к разработке серверных приложений\cite{Fritzsch2018MonolithToMicroservices}. Она характеризуется модульностью, то есть каждый модуль является отдельным сервисом, который может быть развернут и масштабирован отдельно от других модулей. Микросервисная архитектура рассматривает приложение как совокупность небольших сервисов, которые представляют отдельные функции приложения. Каждый сервис обычно работает независимо от других сервисов, используя API для обмена данными между другими сервисами.
Основное преимущество микросервисной архитектуры заключается в ее модульности. Это дает возможность быстро отвечать на изменения требований и легко масштабировать приложение по мере необходимости. Другим преимуществом микросервисной архитектуры является возможность использования различных технологий и языков программирования для различных сервисов. Это позволяет использовать наилучшее решение для каждой отдельной задачи. Микросервисная архитектура может быть также более устойчивой и надежной, поскольку имеется возможность аварийного отключения отдельных сервисов, позволяя уменьшить влияние отказа других компонентов на работу приложения в целом.
Существует несколько типов микросервисных архитектур, которые различаются по тому, как организованы и взаимодействуют между собой микросервисы. К одному из распространенных типов микросервисных архитектур относится оркестрованная архитектура [8] – это такая архитектура, в которой существует централизованный компонент или слой, называемый оркестратором, который координирует действия и взаимодействие других микросервисов в системе. Оркестратор отвечает за управление жизненным циклом запросов от клиентов, контроль последовательности выполнения операций и обработку бизнес-логики интеграции между сервисами. 
Ещё одним из распространённых типов микросервисных архитектур является event-driven архитектура – архитектура, в которой микросервисы взаимодействуют через отправку и прием событий. Каждый сервис может публиковать события, на которые другие сервисы могут, соответственно, подписываться и реагировать. К её преимуществам относятся: гибкость (компоненты могут быть легко добавлены или удалены без влияния на другие части системы), масштабируемость (каждый компонент может масштабироваться независимо для обеспечения высокой производительности), отказоустойчивость (отказ одного компонента не блокирует работу всей системы). Однако тут возникает сложность в обеспечении согласованности данных между различными сервисами, управлении событиями и обработке ошибок.
Также стоит упомянуть про подход API Gateway – данный тип архитектуры использует централизованный шлюз, который является единой точкой входа для всех запросов клиентов к микросервисам или другим системам. Шлюз может выполнять несколько функций, к которым относятся: аутентификация, авторизация, маршрутизация запросов, преобразование протоколов и форматов данных, кеширование, балансировка трафика и другие. Данный подход позволяет сделать архитектуру приложения более гибкой, безопасной и легкой в управлении, а также позволяет централизованно управлять всеми взаимодействиями клиентов с микросервисами, упрощая развертывание и поддержку системы.

Микросервисная архитектура предусматривает разбиение приложения на небольшие независимые сервисы, каждый из которых выполняет строго определённые задачи. Эти сервисы взаимодействуют через сети с использованием API или брокеров сообщений.

\textbf{Преимущества микросервисной архитектуры}:
\begin{itemize}
    \item \textbf{Гибкость масштабирования:} отдельные сервисы масштабируются независимо, что оптимизирует использование ресурсов.
    \item \textbf{Свобода выбора технологий:} команды могут использовать разные языки программирования и инструменты для реализации отдельных сервисов.
    \item \textbf{Лучшая управляемость:} изолированные сервисы упрощают внесение изменений и поддержку.
    \item \textbf{Повышенная устойчивость:} сбой одного сервиса не влияет на работу других.
    \item \textbf{Параллельная разработка:} команды могут работать над разными сервисами одновременно.
\end{itemize}

\textbf{Недостатки микросервисной архитектуры}:
\begin{itemize}
    \item \textbf{Сложность проектирования:} требует тщательного планирования взаимодействия между сервисами.
    \item \textbf{Проблемы с согласованностью данных:} переход к eventual consistency добавляет сложности.
    \item \textbf{Высокие инфраструктурные затраты:} управление множеством сервисов требует дополнительных инструментов, таких как Kubernetes.
    \item \textbf{Увеличение задержек:} сетевое взаимодействие между сервисами медленнее, чем вызовы в памяти.
    \item \textbf{Сложности диагностики:} распределённый характер системы затрудняет выявление и исправление ошибок.
\end{itemize}

\subsection{Монолитная архитектура}

Монолитная архитектура представляет собой подход, при котором всё приложение разрабатывается как единый, неделимый блок. В нём объединены пользовательский интерфейс, бизнес-логика и уровень работы с данными. Такой подход исторически был основным в разработке ПО.

\textbf{Преимущества монолитной архитектуры}:
\begin{itemize}
    \item \textbf{Простота разработки:} начальный этап разработки требует меньше усилий на планирование структуры.
    \item \textbf{Единая кодовая база:} централизованное хранение и управление кодом упрощает процесс разработки и интеграции изменений.
    \item \textbf{Простая инфраструктура:} одно монолитное приложение, не требует дополнитнельных расходов на инфраструктуру.
    \item \textbf{Высокая производительность:} отсутствие сетевого взаимодействия между компонентами ускоряет их взаимодействие.
    \item \textbf{Поддержка транзакционности:} встроенные механизмы работы с транзакциями позволяют обеспечить согласованность данных.
\end{itemize}

\textbf{Недостатки монолитной архитектуры}:
\begin{itemize}
    \item \textbf{Сложность масштабирования:} увеличение нагрузки требует масштабирования всего приложения, даже если это касается лишь одного его компонента.
    \item \textbf{Ограничения технологического выбора:} единая технологическая платформа ограничивает возможности внедрения новых инструментов.
    \item \textbf{Рост сложности кода:} по мере увеличения объёма функциональности поддержка системы становится сложнее.
    \item \textbf{Долгое развертывание:} внесение малейших изменений требует пересборки и перезапуска приложения.
    \item \textbf{Уязвимость к сбоям:} сбой в одном компоненте приводит к отказу всей системы.
\end{itemize}


\subsection{Сравнение монолитной и микросервисной архитектур}

Для более наглядного понимания различий между монолитной и микросервисной архитектурами представим их основные аспекты в таблице:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Аспект}                & \textbf{Монолит}       & \textbf{Микросервисы}   \\ \hline
Сложность разработки           & Низкая                                 & Высокая                                \\ \hline
Масштабируемость               & Ограниченная                           & Гибкая                                 \\ \hline
Устойчивость к сбоям           & Низкая                                 & Высокая                                \\ \hline
Технологический выбор          & Ограниченный                           & Гибкий                                 \\ \hline
Развертывание                  & Простое                                & Сложное                                \\ \hline
Поддержка транзакционности     & Простая                                & Сложная                                \\ \hline
Задержки взаимодействия        & Минимальные                            & Увеличенные                            \\ \hline
Затраты на инфраструктуру      & Низкие                                 & Высокие                                \\ \hline
\end{tabular}
\caption{Сравнение монолитной и микросервисной архитектур}
\end{table}

\textbf{Выводы:} Монолитная архитектура лучше подходит для проектов с ограниченным функционалом и небольшими командами, где важны простота и быстрота разработки. Микросервисы же оправданы в сложных, масштабируемых системах с распределёнными командами и высокими требованиями к отказоустойчивости.\cite{Ahmed2022MicroservicesVsMonolithic}













\section{Анализ и сравнение паттернов проектирования модулей системы}

Связанность (англ. Coupling) и согласованность (англ. Cohesion) являются фундаментальными концепциями в области разработки программного обеспечения\cite{Alzamil2023CouplingCohesionModel}, которые оказывают значительное влияние на читаемость, поддержку, тестируемость и переиспользование кода. В данной работе исследуются эти понятия, их виды, а также взаимосвязь между ними с целью формирования рекомендаций по их применению для повышения эффективности разработки.

\subsection*{Связанность (Coupling)}

Связанность характеризует степень зависимости одного программного модуля от других. Чем выше уровень связанности, тем сильнее изменения в одном модуле отражаются на других. Стремление к низкой связанности (low coupling) является ключевым принципом проектирования, позволяющим минимизировать количество зависимостей между модулями и повысить их автономность.

Существует несколько типов связанности, классифицируемых по степени их зависимости:

\begin{itemize}
    \item \textbf{Content coupling} (содержательная связанность): возникает, когда один модуль полагается на внутреннюю реализацию другого модуля, например, доступ к его локальным данным. Изменения в одном модуле требуют изменений в другом.
    \item \textbf{Common coupling} (общая связанность): модули используют общие данные, например, глобальные переменные. Изменение этих данных затрагивает все модули, которые с ними работают.
    \item \textbf{External coupling} (внешняя связанность): несколько модулей зависят от общего внешнего ресурса, такого как сервис или API. Изменения в этом ресурсе могут привести к некорректной работе модулей.
    \item \textbf{Control coupling} (управляющая связанность): один модуль управляет поведением другого через передачу управляющих сигналов, например, флагов, изменяющих поведение функций.
    \item \textbf{Stamp coupling} (штампованная связанность): модули обмениваются сложными структурами данных, однако используют лишь их часть. Это может приводить к побочным эффектам из-за неполной или изменяемой информации.
    \item \textbf{Data coupling} (связанность по данным): наименее инвазивный тип, при котором модули взаимодействуют исключительно через передачу конкретных данных. Такой подход минимизирует взаимозависимость.
\end{itemize}

\subsection*{Согласованность (Cohesion)}

Согласованность характеризует степень внутренней связанности функциональных элементов модуля. Высокая согласованность подразумевает, что все компоненты модуля ориентированы на выполнение одной конкретной задачи или функции, что улучшает читаемость и управляемость кода.\cite{HenryKafura1981ComplexityMetrics}

Типы согласованности включают:

\begin{itemize}
    \item \textbf{Functional cohesion} (функциональная согласованность): модуль объединяет весь необходимый функционал для выполнения одной задачи.
    \item \textbf{Sequential cohesion} (последовательная согласованность): результаты одной функции используются в качестве входных данных для другой.
    \item \textbf{Communication cohesion} (коммуникационная согласованность): все элементы модуля работают с одними и теми же данными.
    \item \textbf{Procedural cohesion} (процедурная согласованность): элементы модуля выполняются в определенной последовательности, необходимой для достижения результата.
    \item \textbf{Temporal cohesion} (временная согласованность): функции модуля сгруппированы на основе их выполнения в определенный момент времени (например, при обработке ошибок).
    \item \textbf{Logical cohesion} (логическая согласованность): элементы модуля объединены логически общей функцией, но могут отличаться по своей природе (например, обработка различных типов ввода).
    \item \textbf{Coincidental cohesion} (случайная согласованность): элементы модуля не связаны логически, что делает модуль хаотичным и сложным для понимания.
\end{itemize}

\subsection*{Взаимосвязь между Coupling и Cohesion}

Связанность и согласованность находятся в сложной взаимозависимости\cite{ChidamberKemerer1994MetricsSuite}. Уменьшение связанности обычно способствует увеличению согласованности и наоборот. Например, избыточная согласованность может привести к росту зависимости между модулями, что увеличивает связанность. Таким образом, ключевым аспектом является нахождение оптимального баланса, который обеспечит поддержку высокого уровня согласованности при минимально возможной связанности.

Применение принципов низкой связанности и высокой согласованности позволяет создавать поддерживаемые, масштабируемые и понятные программные системы\cite{Microsoft2008PatternsCouplingCohesion}. Их использование способствует не только повышению качества кода, но и ускорению разработки, что особенно важно в современных условиях высокой конкуренции и быстрого изменения требований.





\subsection{Луковая архитектура}
\textbf{Луковая архитектура} была предложена Джеффри Палермо в 2008 году как расширение гексагональной архитектуры\cite{Shalloway2020ArchitecturalPatterns}. Её цель — облегчить поддержку приложений за счёт разделения аспектов и строгих правил взаимодействия слоёв.

\subsubsection{Основная идея}
Луковая архитектура предполагает многослойную организацию системы, где каждый слой зависит только от внутреннего слоя. Центральным слоем всегда является независимый слой, который представляет собой сердцевину архитектуры. Остальные слои располагаются вокруг него, создавая структуру, похожую на лук.

\textbf{Ключевые принципы:}
\begin{itemize}
    \item Приложение строится вокруг независимой объектной модели.
    \item Внутренние слои определяют интерфейсы, внешние — реализуют их.
    \item Зависимости направлены к центру.
    \item Код предметной области изолирован от инфраструктуры.
\end{itemize}

\subsubsection{Слои}
\textbf{Domain Model:} содержит основные сущности и поведение предметной области, например, валидацию данных.

\textbf{Domain Services:} реализует бизнес-логику, которая не связана с конкретными сущностями, например, расчёт стоимости заказа.

\textbf{Application Services:} оркестрирует бизнес-логику, например, обработку запроса на создание заказа.

\textbf{Infrastructure:} реализует интерфейсы и адаптеры для работы с базами данных, внешними API и другими ресурсами.

\subsubsection{Преимущества}
\begin{itemize}
    \item Независимость предметной области от инфраструктуры.
    \item Гибкость замены внешних слоёв.
    \item Высокая тестируемость.
\end{itemize}

\subsubsection{Недостатки}
\begin{itemize}
    \item Сложность обучения.
    \item Необходимость создания множества интерфейсов.
\end{itemize}

\subsection{Hexagonal Architecture}
\textbf{Hexagonal Architecture} (также известная как Ports and Adapters) была предложена Alistair Cockburn\cite{Cockburn2025HexagonalArchitecture}. Её цель — устранить зависимость бизнес-логики от внешних систем и сделать приложение более гибким и тестируемым.

\subsubsection{Основная идея}
Hexagonal Architecture представляет приложение в виде шестиугольника, где каждая сторона представляет интерфейс (порт) для взаимодействия с внешними системами (адаптерами). Центр архитектуры — это бизнес-логика, изолированная от деталей реализации.

\textbf{Ключевые принципы:}
\begin{itemize}
    \item Бизнес-логика полностью изолирована от инфраструктуры.
    \item Взаимодействие с внешним миром происходит через порты и адаптеры.
    \item Внешние системы подключаются через адаптеры, соответствующие определённым портам.
\end{itemize}

\subsubsection{Слои}
\textbf{Core (Business Logic):} центральная часть архитектуры, содержащая доменные сущности и бизнес-правила.

\textbf{Ports:} интерфейсы, через которые осуществляется взаимодействие между Core и внешними системами.

\textbf{Adapters:} реализация портов для подключения конкретных технологий, таких как базы данных, веб-сервисы и т.д.

\subsubsection{Преимущества}
\begin{itemize}
    \item Гибкость: легко заменять внешние системы, не затрагивая бизнес-логику.
    \item Тестируемость: изолированная бизнес-логика упрощает написание модульных тестов.
    \item Чёткое разделение обязанностей.
\end{itemize}

\subsubsection{Недостатки}
\begin{itemize}
    \item Сложность проектирования и реализации.
    \item Дополнительные накладные расходы на создание портов и адаптеров.
\end{itemize}

\subsection{Чистая архитектура}
\textbf{Чистая архитектура}, предложенная Робертом Мартином, основывается на идеях Onion и Hexagonal архитектур\cite{Shalloway2020ArchitecturalPatterns}. Её ключевая цель — изолировать бизнес-логику от деталей реализации.\cite{Martin2017CleanArchitecture}

\subsubsection{Базовые принципы}
\begin{itemize}
    \item Использование принципов SOLID.
    \item Разделение системы на слои.
    \item Независимость бизнес-логики от инфраструктуры.
    \item Тестируемость бизнес-логики без внешних зависимостей.
\end{itemize}

\subsubsection{Слои}
\textbf{Domain:} содержит общие бизнес-правила, структуры и интерфейсы.

\textbf{Application:} реализует конкретные сценарии использования, например, обработку запросов.

\textbf{Presentation:} отвечает за взаимодействие с пользователем через REST API, CLI и т.д.

\textbf{Infrastructure:} содержит детали реализации, такие как доступ к базе данных или внешние сервисы.

\subsubsection{Пересечение границ}
В чистой архитектуре зависимости направлены внутрь. Внешние слои реализуют интерфейсы, определённые внутренними слоями. Это достигается за счёт принципа инверсии зависимостей (DIP).

\subsubsection{Преимущества}
\begin{itemize}
    \item Независимость от фреймворков и инфраструктуры.
    \item Простота тестирования.
    \item Переносимость и возможность разделения на микросервисы.
\end{itemize}

\subsubsection{Недостатки}
\begin{itemize}
    \item Требуется строгое разделение бизнес-правил.
    \item Возможность излишнего усложнения структуры.
\end{itemize}


\textbf{Вывод}


\textbf{Чистая архитектура} представляет собой эволюцию луковой и гексагональной архитектур, сохраняя их принципы, но делая больший акцент на SOLID и изоляции бизнес-логики. Она подходит для сложных систем, требующих высокой гибкости и тестируемости, но может быть избыточной для небольших приложений.


% Это обзорно-аналитическая глава, в которой требуется отразить:

% \begin{itemize}
% 	\item результат изучения различных существующих методов решения задач в рамках проблематики УИРа/диплома (иногда даже в смежных областях), это обзорный аспект, который пишется, в основном, на основе имеющейся литературы или/и программного обеспечения;
% 	\item сравнение (с какой-либо определенной целью) этих методов и средств.
% \end{itemize}

% Приведенные ниже названия пунктов являются очень примерными, их состав и структура сильно зависят от специфики конкретной работы.




% %Большие отсупы --- это хорошо. Облегчает чтение длинных <<простыней>> текста
% \section{Общий анализ проблематики \dots}

% \begin{annotation}
% В случае РСПЗ, так оформляется аннотация к разделу. Такая же аннотация, только более общая, должна быть для главы. После аннотации может следовать рабочая или финальная версия текста соответствующего раздела. В случае ПЗ, таких аннотаций быть не должно.
% \end{annotation}

% \dots

% Результаты анализа полезно оформлять в виде таблиц (см. табл. \ref{tbl:cmp-1}).

% \begin{table}%
% \caption{Результаты сравнения нескольких программных систем}\label{tbl:cmp-1}
% \centering
% \begin{tabular}{|l|l|c|c|c|c|}

% \hline

% \textnumero & Название системы & Показатель 1 & Показатель 2 & Показатель 3 & Показатель 4 \\

% \hline

% \end{tabular}
% \end{table}


% \section{Анализ особенностей \dots}

% Сначала приведем пример более сложной таблицы (см. табл. \ref{tbl:cmp-adv} и 
% \ref{tbl:cmp-2}).

% \begin{table}%
% \caption{Таблица с длинным, многострочным названием, чтобы показать, как форматируется такой заголовок}
% \label{tbl:cmp-adv}
% \centering
% \begin{tabular}{|l|l|c|c|c|c|}

% \hline

% \textnumero & Название системы & Показатель 1 & Показатель 2 & Показатель 3 & Показатель 4 \\

% \hline

% \end{tabular}
% \label{tbl:cmp-2}
% \end{table}


% А теперь, продемонстрируем, как должна выглядеть иллюстрация (см. рис. \ref{pic:lambda-cube}).

% \begin{figure}[t]%
% \begin{center}
% \includegraphics[width=.5\columnwidth]{./img/lambda-cube.png}%
% \end{center}
% \caption{Ламбда-куб Барендрегта}%
% \label{pic:lambda-cube}%
% \end{figure}

% А теперь, продемонстрируем, как должна выглядеть иллюстрация с длинной подрисуночной подписью (см. рис. \ref{pic:lambda-cube-long-caption}).

% \begin{figure}[t]%
% 	\begin{center}
% 		\includegraphics[width=.5\columnwidth]{./img/lambda-cube.png}%
% 	\end{center}
% 	\caption{Ламбда-куб Барендрегта, иллюстрирующий многообразие систем типизации с точки зрения четырех базовых видов зависимостей между типами и объектами: термов от термов, термов от типов, типов от типов и типов от термов.}%
% 	\label{pic:lambda-cube-long-caption}%
% \end{figure}

% \subsection{Ссылки на литературу}

% В этой версии шаблона используется BibLaTeX, основанный на biber и BibTeX.
% Поэтому для оформления списка литературы используются два файла:
% \texttt{thesis-bibl.tex} и \texttt{biblio.bib}. Использование BibTex дает ряд
% преимуществ. Не нужно заботиться о порядке сортировки, это делается
% автоматически; не нужно заботиться, на какие элементы библиографии есть ссылки
% --- печатаются только использованные в тексте элементы. Кроме того, многие
% курсовые проекты выполняются на протяжении ряда лет. С BibTex проще собирать
% список литературы и управлять им.

% На все элементы списка литературы должны быть ссылки из текста. При
% использовании команды \texttt{\textbackslash{}cite} это происходит
% автоматически. Отсутствиессылок на литературу из текста допускается в РСПЗ,
% т.~е. в РСПЗ список литературы скорее имеет смысл списка подобранной литературы
% по теме или библиографии. Для того, чтобы в списке литературы отобразились
% источники, на которые отсутствуют ссылки в тексте, следует использовать команду
% \texttt{\textbackslash{}nocite}. К примеру, \texttt{\textbackslash{}nocite\{*\}}
% выводит в список литературы все содержимое подключенных BibTeX файлов, вставляя
% невидимые ссылки на них.

% \section{Сравнительный анализ алгоритмов \dots}

% \dots





% \section{Сравнительный анализ программных средств \dots}

% \dots




\section{Выводы}

\begin{enumerate}
    \item Разобраны основные методы применения ИИ в медицине. Особенности применения ИИ ассистентов в работе врача, основные аналоги систем ИИ ассистентов представленных на рынке.
	\item Выполнен анализ архитектурных стилей построения систем, с учетом требований к динамической расширяемости отдельных модулей системы, выбрана микросервисная архитектура с применением API Gateway.
	\item Проанализированы основные архитектурные паттерны построения приложений. Clean Architecture за счет преобраладания SOLID, разбиения на слои и преимуществ Dependency inversion выбрана как основа написания микросервисов.
\end{enumerate}

\section{Постановка цели и задач ВКР}

Целью данной ВКР является разработка системы серверного приложения комплексной системы «Интеллектуальный ассистент врача УЗИ».


Задачи на ВКР:
\begin{enumerate}
    \item Разграничение функционала серверного приложения на доменные области.
    \item Проектирование системы Интеллектуальный ассистент врача УЗИ, с учетом разграничения на доменные области.
    \item Реализация микросервисов в соответствии с принципами Clean Architecture.
	\item Тестирование разработанной системы и ее производительности. Устранение недостатков при наличии.
\end{enumerate}

% Разграничение функционала серверного приложения на изолированные предметные области области.
% Проектирование системы Интеллектуальный ассистент врача УЗИ, с учетом разграничения на предметные области.
% Реализация микросервисов в соответствии с принципами Clean Architecture.
% Тестирование разработанной системы и устранение недостатков при наличии.



%%% Local Variables:
%%% TeX-engine: xetex
%%% eval: (setq-local TeX-master (concat "../" (seq-find (-cut string-match ".*-3-pz\.tex$" <>) (directory-files ".."))))
%%% End:
