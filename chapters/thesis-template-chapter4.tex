\chapter{Реализация и тестирование системы}

\section{Реализация компонентов системы в виде микросервисов}

\subsection{Сущности предметной области}
В каждом микросервисе существует своя предметная область. Все ключевые сущности заданы в виде структур, для оперирования
ими в логике микросервиса.

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.7\columnwidth]{./img/new/domain_node.png}%
	\end{center}
	\caption{Сущности узла образования в щитовидной железе}%
	\label{pic:domain_node}%
\end{figure}

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.7\columnwidth]{./img/new/domain_node_status.png}%
	\end{center}
	\caption{Статусы узла образования в щитовидной железе}%
	\label{pic:domain_node_status}%
\end{figure}

Сущности предметной области не имеют зависимостей от внешних частей или структур системы.

\subsection{Логические сценарии использования}
Вся логика которая имеется в микросервисе реализована в этом слое приложения. Никакая логика не допустима в другом месте. 
Такой подход к разработке позволяет легко отлаживать и контролировать систему, она не <<растякается>> по всему коду.

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.7\columnwidth]{./img/new/logical.png}%
	\end{center}
	\caption{Логическая удаления узла образования}%
	\label{pic:logical}%
\end{figure}

\subsection{Интерфейсы взаимодействия с внешними системами}
Для сохранения правила Dependency Inversion, все взаимодействия с внешними системами реализованы через интерфейсы, чей уровень
абстракции такого же уровня, что и уровень абстракции вызывающего интерфейс. Рассмотрим пример интерфейса для взаимодействия с 
базой данных.

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.7\columnwidth]{./img/new/repository.png}%
	\end{center}
	\caption{Интерфейс взаимодействия с базой данных для узлов образований}%
	\label{pic:repository}%
\end{figure}

\subsection{Контракты микросервисов и API системы}
Все микросервисы взаимодействуют с друг другом посредством gRPC. Описания контрактов взаимодействия делается посредством
proto файлов. В них описываются rpc методы микросервиса, которые он реализует. Описаны ожидаемые структуры данных, которые 
используются в rpc методах.

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.7\columnwidth]{./img/new/rpc_proto_1.png}%
	\end{center}
	\caption{Контракт взаимодействия с микросервисом управления УЗИ снимками}%
	\label{pic:rpc_proto_1}%
\end{figure}

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.7\columnwidth]{./img/new/rpc_proto_2.png}%
	\end{center}
	\caption{Контракт взаимодействия с микросервисом управления УЗИ снимками}%
	\label{pic:rpc_proto_2}%
\end{figure}

Далее рассмотрим API системы в целом. Этот API должен в полной мере покрывать все функциональные требования к системе, 
относящиеся к взаимодействию с системой. API системы описывается файлом в формате OpenAPI 3.0.

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.7\columnwidth]{./img/new/swagger_small.png}%
	\end{center}
	\caption{API системы}%
	\label{pic:swagger_small}%
\end{figure}

\subsection{Топики стриминга сообщений для асинхронного общения}
Для использования асинхронного общения через RedPanda, создадим 3 топика:
\begin{itemize}
    \item \textbf{uziupload} - узи загруженно в S3. Запустит разбиение узи на кадры.
    \item \textbf{uzisplitted} - узи разбито на кадры. Запустит обработку узи нейро моделью. В топик пишет сервис управления УЗИ после разбиения узи на кадры.
    \item \textbf{uziprocessed} - узи обработанно нейромоделью. Узи сегментировано и классифицировано
\end{itemize}

\subsection{Структура хранилища узи снимков}
Структура S3 minio представлена в виде файловой системы, позволяет быстро искать необходимые файлы, зная их идентификатор. 
Микросервисы знают об устройстве S3, поэтому при необходимости передчи в другой микросервис узи снимков, достаточно передавать
id снимка.

\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.6\columnwidth]{./img/s3_arc.png}%
	\end{center}
	\caption{Структура S3 хранилища}%
	\label{pic:auth_model}%
\end{figure}


% В этой главе описывается, что и как было запрограммировано, отлажено, 
% протестировано, и что в результате получилось. Большинство работ должны 
% содержать приведенные ниже разделы. Но нужно учитывать, что точный состав 
% этой главы, как и других глав, зависит от специфики работы.

% Фрагменты программного кода в тексте необходимо выделять при помощи команды 
% \verb|\verb|. Многострочные листинги должны оформляться при помощи пакета 
% \verb|listings|. Пример:

% \begin{lstlisting}
% # let s x y z = x z (y z);;
% val s : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c = <fun>
% # let k x y = x;;
% val k : 'a -> 'b -> 'a = <fun>
% # let i = s k k;;
% val i : '_a -> '_a = <fun>
% \end{lstlisting}

% Листинг \ref{lst:float-example} иллюстрирует использование выносных листингов.
% Листинг \ref{lst:HelloWorld.scala} показывает пример включения внешнего файла 
% в качестве листинга, в данном случае --- выносного.

% \begin{lstlisting}[
%   float=tb,frame=lines,label=lst:float-example,caption=Выносной листинг
% ]
% List myList = new List();
% Element myElement = new Element();
% myList.Append(myElement);
% \end{lstlisting}

% \lstinputlisting[
%   label=lst:HelloWorld.scala,
%   float=tb,frame=lines,
%   caption=Листинг из файла \texttt{HelloWorld.scala}
% ]{listings/HelloWorld.scala}


\section{Состав и структура реализованного программного обеспечения}

Реализованно серверное приложение, запускаемое как для локального использование, так и в 
серверном виде. Приложений отвечает на HTTP запросы, соответствует всем функциональным требованиям к системе.

\subsection{Структура приложения}
Приложение состоит из 5 микросервисов:
\begin{itemize}
  \item Composition API - точка входа в систему. Обрабатывает запросы от пользователя и передает их в соответствующие микросервисы.
  \item Микросервис Авторизации и Аутентификации - отвечает за аутентификацию и авторизацию пользователей.
  \item Микросервис Управления УЗИ снимками - отвечает за загрузку, разбиение на кадры, обработку узи нейромоделью.
  \item Микросервис Управления Медицинскими данными - отвечает за хранение и обработку медицинских данных.
  \item Микросервис Интеллектуальной части - отвечает за обработку узи нейромоделью.
\end{itemize}

Каждый микросервис написанный на golang содержит:
\begin{itemize}
  \item go.mod и go.sum файлы, описывающие библиотекчные зависимости для приложения
  \item sql файлы миграций. Сами миграции осуществлялись за счет утилиты Goose. SQL файлы в каждом микросервисе расположены по пути db/migrations
  \item proto файлы описывающие контракты для взаимодествия с внешними системами
  \item taskfile - файлы описывающие команды необходимые для локальной сборки микросервиса, миграции базы данных, генерации кода и т.д
  \item Dockerfile - файл для сборки docker образа микросервиса
  \item service.yml - файл содержащий конфигурацию сервиса
\end{itemize}


% Нужно охарактеризовать реализованное ПО: является ли оно настольной программной для Windows, 
% или веб-приложением в форме сайта/веб-сервиса, или модулем/подключаемой библиотекой, или 
% \dots. Также нужно перечислить, из чего оно состоит: какие исполняемые файлы и их назначение, 
% конфигурационные файлы, файлы баз данных, требования к программному и аппаратному окружению, и т.п.

% Если реализованное приложение достаточно обширно, этот раздел может быть
% разделен на несколько: один с общим описанием, и по одному на подсистемы самого
% верхнего уровня.

\section{Основные сценарии работы пользователя}
Основной сценарий работы ПО - отправка запросов на обработку узи изображений и полученние данных с
обработанных изображений. Для взаимодействием с сервисом предоставляется подробное swagger api.
\begin{figure}[H]%
	\begin{center}
		\includegraphics[width=.9\columnwidth]{./img/swagger.png}%
	\end{center}
	\caption{Спроектированная база данных Auth Service}%
	\label{pic:auth_model}%
\end{figure}

% Нужно помнить, что пользователем может быть не только <<менеджер>> или <<человек в белом халате>>, 
% но и другой программист. Последнее относится, в первую очередь, к реализованным библиотекам. 
% Для <<обычных>> приложений нередко бывают пользователи нескольких категорий --- например, обычный 
% пользователь и администратор. Для каждой категории нужно описать, как выполняются основные функции, 
% предпочтительно, с помощью серии скрин-шотов. Однако считается плохим тоном вставлять длинную вереницу 
% из скрин-шотов: если их много, большую часть нужно выносить в приложение. Для \textit{этого} раздела 
% нормальной является плотность скрин-шотов из расчета: 1 страница скрин-шотов на 1-2 страницы текста.


\section{Выводы}
Таким образом, в рамках НИРа было реализовано 4 микросервиса серверного приложения, а также были проведены некоторые типы тестирования реализации. 
В будущем планируется развернуть систему на нескольких физическим машинах с использованием оркестратора контейнеризированных приложений 
kubernetus и повторно провести нагрузочное и интеграционное тестирование.

% Следует перечислить, какие практические результаты были получены, а именно: какое 
% программное или иное обеспечение было создано. В число результатов могут входить, 
% например, методики тестирования, тестовые примеры (для проверки корректности/оценки 
% характеристик тех или иных алгоритмов) и др. По каждому результату следует сделать вывод, 
% насколько он отличается от известных промышленных аналогов и исследовательских прототипов.



%%% Local Variables:
%%% TeX-engine: xetex
%%% eval: (setq-local TeX-master (concat "../" (seq-find (-cut string-match ".*-3-pz\.tex$" <>) (directory-files ".."))))
%%% End:
